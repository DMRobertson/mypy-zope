from typing import (
    TYPE_CHECKING,
    Iterable,
    Optional,
    Union, Any,
)

from zope.interface import Attribute, Interface

from twisted.python.failure import Failure

if TYPE_CHECKING:
    try:
        from OpenSSL.SSL import (
            Connection as OpenSSLConnection,
            Context as OpenSSLContext,
        )
    except ImportError:
        OpenSSLConnection = OpenSSLContext = object  # type: ignore[misc,assignment]

    from twisted.internet.defer import Deferred


class ILoggingContext(Interface):
    """
    Give context information that will be used to log events generated by
    this item.
    """

    def logPrefix() -> str:
        """
        @return: Prefix used during log formatting to indicate context.
        """


class IProtocol(Interface):
    def dataReceived(data: bytes) -> None:
        """
        Called whenever data is received.

        Use this method to translate to a higher-level message.  Usually, some
        callback will be made upon the receipt of each complete protocol
        message.

        Please keep in mind that you will probably need to buffer some data
        as partial (or multiple) protocol messages may be received!  We
        recommend that unit tests for protocols call through to this method
        with differing chunk sizes, down to one byte at a time.

        @param data: bytes of indeterminate length
        """

    def connectionLost(reason: Failure) -> None:
        """
        Called when the connection is shut down.

        Clear any circular references here, and any external references
        to this Protocol.  The connection has been closed. The C{reason}
        Failure wraps a L{twisted.internet.error.ConnectionDone} or
        L{twisted.internet.error.ConnectionLost} instance (or a subclass
        of one of those).
        """

    def makeConnection(transport: "ITransport") -> None:
        """
        Make a connection to a transport and a server.
        """

    def connectionMade() -> None:
        """
        Called when a connection is made.

        This may be considered the initializer of the protocol, because
        it is called when the connection is completed.  For clients,
        this is called once the connection to the server has been
        established; for servers, this is called after an accept() call
        stops blocking and a socket has been received.  If you need to
        send any greeting or initial message, do it here.
        """


class IProtocolFactory(Interface):
    """
    Interface for protocol factories.
    """

    def buildProtocol(addr: Any) -> Optional[IProtocol]:
        """
        Called when a connection has been established to addr.

        If None is returned, the connection is assumed to have been refused,
        and the Port will close the connection.

        @param addr: The address of the newly-established connection

        @return: None if the connection was refused, otherwise an object
                 providing L{IProtocol}.
        """

    def doStart() -> None:
        """
        Called every time this is connected to a Port or Connector.
        """

    def doStop() -> None:
        """
        Called every time this is unconnected from a Port or Connector.
        """


class ITransport(Interface):
    """
    I am a transport for bytes.

    I represent (and wrap) the physical connection and synchronicity
    of the framework which is talking to the network.  I make no
    representations about whether calls to me will happen immediately
    or require returning to a control loop, or whether they will happen
    in the same or another thread.  Consider methods of this class
    (aside from getPeer) to be 'thrown over the wall', to happen at some
    indeterminate time.
    """

    def write(data: bytes) -> None:
        """
        Write some data to the physical connection, in sequence, in a
        non-blocking fashion.

        If possible, make sure that it is all written.  No data will
        ever be lost, although (obviously) the connection may be closed
        before it all gets through.

        @param data: The data to write.
        """

    def writeSequence(data: Iterable[bytes]) -> None:
        """
        Write an iterable of byte strings to the physical connection.

        If possible, make sure that all of the data is written to
        the socket at once, without first copying it all into a
        single byte string.

        @param data: The data to write.
        """

    def loseConnection() -> None:
        """
        Close my connection, after writing all pending data.

        Note that if there is a registered producer on a transport it
        will not be closed until the producer has been unregistered.
        """

    def getPeer() -> Any:
        """
        Get the remote address of this connection.

        Treat this method with caution.  It is the unfortunate result of the
        CGI and Jabber standards, but should not be considered reliable for
        the usual host of reasons; port forwarding, proxying, firewalls, IP
        masquerading, etc.

        @return: An L{Any} provider.
        """

    def getHost() -> Any:
        """
        Similar to getPeer, but returns an address describing this side of the
        connection.

        @return: An L{Any} provider.
        """

